// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package app_test

import (
	"github.com/google/uuid"
	"github.com/theskyinflames/cqrs-eda/pkg/events"
	"net"
	"sync"
	"theskyinflames/core-tech/publisher/internal/app"
	"theskyinflames/core-tech/publisher/internal/domain"
)

// Ensure, that SubscribersMock does implement app.Subscribers.
// If this is not the case, regenerate this file with moq.
var _ app.Subscribers = &SubscribersMock{}

// SubscribersMock is a mock implementation of app.Subscribers.
//
//	func TestSomethingThatUsesSubscribers(t *testing.T) {
//
//		// make and configure a mocked app.Subscribers
//		mockedSubscribers := &SubscribersMock{
//			AddFunc: func(subscriber domain.Subscriber)  {
//				panic("mock out the Add method")
//			},
//			EventsFunc: func() []events.Event {
//				panic("mock out the Events method")
//			},
//			LenFunc: func() int {
//				panic("mock out the Len method")
//			},
//			RemoveFunc: func(conn net.Conn)  {
//				panic("mock out the Remove method")
//			},
//			StreamFunc: func(sl domain.StreamFunction)  {
//				panic("mock out the Stream method")
//			},
//			SubscriberFunc: func(uUID uuid.UUID) (domain.Subscriber, error) {
//				panic("mock out the Subscriber method")
//			},
//		}
//
//		// use mockedSubscribers in code that requires app.Subscribers
//		// and then make assertions.
//
//	}
type SubscribersMock struct {
	// AddFunc mocks the Add method.
	AddFunc func(subscriber domain.Subscriber)

	// EventsFunc mocks the Events method.
	EventsFunc func() []events.Event

	// LenFunc mocks the Len method.
	LenFunc func() int

	// RemoveFunc mocks the Remove method.
	RemoveFunc func(conn net.Conn)

	// StreamFunc mocks the Stream method.
	StreamFunc func(sl domain.StreamFunction)

	// SubscriberFunc mocks the Subscriber method.
	SubscriberFunc func(uUID uuid.UUID) (domain.Subscriber, error)

	// calls tracks calls to the methods.
	calls struct {
		// Add holds details about calls to the Add method.
		Add []struct {
			// Subscriber is the subscriber argument value.
			Subscriber domain.Subscriber
		}
		// Events holds details about calls to the Events method.
		Events []struct {
		}
		// Len holds details about calls to the Len method.
		Len []struct {
		}
		// Remove holds details about calls to the Remove method.
		Remove []struct {
			// Conn is the conn argument value.
			Conn net.Conn
		}
		// Stream holds details about calls to the Stream method.
		Stream []struct {
			// Sl is the sl argument value.
			Sl domain.StreamFunction
		}
		// Subscriber holds details about calls to the Subscriber method.
		Subscriber []struct {
			// UUID is the uUID argument value.
			UUID uuid.UUID
		}
	}
	lockAdd        sync.RWMutex
	lockEvents     sync.RWMutex
	lockLen        sync.RWMutex
	lockRemove     sync.RWMutex
	lockStream     sync.RWMutex
	lockSubscriber sync.RWMutex
}

// Add calls AddFunc.
func (mock *SubscribersMock) Add(subscriber domain.Subscriber) {
	callInfo := struct {
		Subscriber domain.Subscriber
	}{
		Subscriber: subscriber,
	}
	mock.lockAdd.Lock()
	mock.calls.Add = append(mock.calls.Add, callInfo)
	mock.lockAdd.Unlock()
	if mock.AddFunc == nil {
		return
	}
	mock.AddFunc(subscriber)
}

// AddCalls gets all the calls that were made to Add.
// Check the length with:
//
//	len(mockedSubscribers.AddCalls())
func (mock *SubscribersMock) AddCalls() []struct {
	Subscriber domain.Subscriber
} {
	var calls []struct {
		Subscriber domain.Subscriber
	}
	mock.lockAdd.RLock()
	calls = mock.calls.Add
	mock.lockAdd.RUnlock()
	return calls
}

// Events calls EventsFunc.
func (mock *SubscribersMock) Events() []events.Event {
	callInfo := struct {
	}{}
	mock.lockEvents.Lock()
	mock.calls.Events = append(mock.calls.Events, callInfo)
	mock.lockEvents.Unlock()
	if mock.EventsFunc == nil {
		var (
			eventsOut []events.Event
		)
		return eventsOut
	}
	return mock.EventsFunc()
}

// EventsCalls gets all the calls that were made to Events.
// Check the length with:
//
//	len(mockedSubscribers.EventsCalls())
func (mock *SubscribersMock) EventsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockEvents.RLock()
	calls = mock.calls.Events
	mock.lockEvents.RUnlock()
	return calls
}

// Len calls LenFunc.
func (mock *SubscribersMock) Len() int {
	callInfo := struct {
	}{}
	mock.lockLen.Lock()
	mock.calls.Len = append(mock.calls.Len, callInfo)
	mock.lockLen.Unlock()
	if mock.LenFunc == nil {
		var (
			nOut int
		)
		return nOut
	}
	return mock.LenFunc()
}

// LenCalls gets all the calls that were made to Len.
// Check the length with:
//
//	len(mockedSubscribers.LenCalls())
func (mock *SubscribersMock) LenCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLen.RLock()
	calls = mock.calls.Len
	mock.lockLen.RUnlock()
	return calls
}

// Remove calls RemoveFunc.
func (mock *SubscribersMock) Remove(conn net.Conn) {
	callInfo := struct {
		Conn net.Conn
	}{
		Conn: conn,
	}
	mock.lockRemove.Lock()
	mock.calls.Remove = append(mock.calls.Remove, callInfo)
	mock.lockRemove.Unlock()
	if mock.RemoveFunc == nil {
		return
	}
	mock.RemoveFunc(conn)
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//
//	len(mockedSubscribers.RemoveCalls())
func (mock *SubscribersMock) RemoveCalls() []struct {
	Conn net.Conn
} {
	var calls []struct {
		Conn net.Conn
	}
	mock.lockRemove.RLock()
	calls = mock.calls.Remove
	mock.lockRemove.RUnlock()
	return calls
}

// Stream calls StreamFunc.
func (mock *SubscribersMock) Stream(sl domain.StreamFunction) {
	callInfo := struct {
		Sl domain.StreamFunction
	}{
		Sl: sl,
	}
	mock.lockStream.Lock()
	mock.calls.Stream = append(mock.calls.Stream, callInfo)
	mock.lockStream.Unlock()
	if mock.StreamFunc == nil {
		return
	}
	mock.StreamFunc(sl)
}

// StreamCalls gets all the calls that were made to Stream.
// Check the length with:
//
//	len(mockedSubscribers.StreamCalls())
func (mock *SubscribersMock) StreamCalls() []struct {
	Sl domain.StreamFunction
} {
	var calls []struct {
		Sl domain.StreamFunction
	}
	mock.lockStream.RLock()
	calls = mock.calls.Stream
	mock.lockStream.RUnlock()
	return calls
}

// Subscriber calls SubscriberFunc.
func (mock *SubscribersMock) Subscriber(uUID uuid.UUID) (domain.Subscriber, error) {
	callInfo := struct {
		UUID uuid.UUID
	}{
		UUID: uUID,
	}
	mock.lockSubscriber.Lock()
	mock.calls.Subscriber = append(mock.calls.Subscriber, callInfo)
	mock.lockSubscriber.Unlock()
	if mock.SubscriberFunc == nil {
		var (
			subscriberOut domain.Subscriber
			errOut        error
		)
		return subscriberOut, errOut
	}
	return mock.SubscriberFunc(uUID)
}

// SubscriberCalls gets all the calls that were made to Subscriber.
// Check the length with:
//
//	len(mockedSubscribers.SubscriberCalls())
func (mock *SubscribersMock) SubscriberCalls() []struct {
	UUID uuid.UUID
} {
	var calls []struct {
		UUID uuid.UUID
	}
	mock.lockSubscriber.RLock()
	calls = mock.calls.Subscriber
	mock.lockSubscriber.RUnlock()
	return calls
}
